/*
    Copyright 2005 VTT Biotechnology

    This file is part of MZmine.

    MZmine is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    MZmine is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with MZmine; if not, write to the Free Software
    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
*/
package net.sf.mzmine.userinterface;
import net.sf.mzmine.alignmentresultmethods.*;
import net.sf.mzmine.alignmentresultvisualizers.*;
import net.sf.mzmine.datastructures.*;
import net.sf.mzmine.distributionframework.*;
import net.sf.mzmine.miscellaneous.*;
import net.sf.mzmine.peaklistmethods.*;
import net.sf.mzmine.rawdatamethods.*;
import net.sf.mzmine.rawdatavisualizers.*;
import net.sf.mzmine.userinterface.*;


// Java packages
import java.util.Hashtable;
import java.util.Enumeration;
import java.util.Vector;
import javax.swing.table.AbstractTableModel;
import javax.swing.JInternalFrame;
import javax.swing.JDesktopPane;


/**
 *
 */
public class ClientDialog extends JInternalFrame {

	private JobInfoModel jobInfo;

	private JInternalFrame previousFrame;
	private JDesktopPane mainWinDesktop;

    /** Creates new form ClientDialog */
    public ClientDialog(MainWindow mainWin) {
		//super(mainWin, true);

		super();
		mainWinDesktop = mainWin.getDesktop();
		previousFrame = mainWinDesktop.getSelectedFrame();

		mainWinDesktop.add(this);
        initComponents();
        setLocation(mainWinDesktop.getWidth()/2-getWidth()/2, mainWinDesktop.getHeight()/2-getHeight()/2 );
    }

    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    private void initComponents() {//GEN-BEGIN:initComponents
        jOverallProgress = new javax.swing.JProgressBar(0,100);
        jJobScroll = new javax.swing.JScrollPane();
        jJobTable = new javax.swing.JTable();

        setDefaultCloseOperation(javax.swing.WindowConstants.DO_NOTHING_ON_CLOSE);
        setTitle("MZmine is operating, please wait...");
        getContentPane().add(jOverallProgress, java.awt.BorderLayout.SOUTH);

		// Initialize job table
		jobInfo = new JobInfoModel();
		jJobTable.setModel(jobInfo);

        jJobScroll.setViewportView(jJobTable);

        getContentPane().add(jJobScroll, java.awt.BorderLayout.CENTER);

        pack();
    }//GEN-END:initComponents


    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JProgressBar jOverallProgress;
    private javax.swing.JScrollPane jJobScroll;
    private javax.swing.JTable jJobTable;
    // End of variables declaration//GEN-END:variables

    public void addJob(Integer jobID, String jobDescription, String nodeName, String jobStatus, Double jobCompletionRate) {
		jobInfo.addJob(jobID, jobDescription, nodeName, jobStatus, jobCompletionRate);
	}

	public void updateJobNode(Integer jobID, String nodeName) {
		jobInfo.updateJobNode(jobID, nodeName);
	}

	public void updateJobStatus(Integer jobID, String jobStatus, Double jobCompletionRate) {
		jobInfo.updateJobStatus(jobID, jobStatus, jobCompletionRate);
		jOverallProgress.setValue((int)java.lang.Math.round(jobInfo.getAverageCompletionRate()*100.0));
	}

	public void showMe() {
		/*
		Thread t = new Thread(
						new Runnable() {
							public void run() {
								setVisible(true);
							}
						}
					);

		t.start();
		*/
		setVisible(true);
	}

	public void hideMe() {

		setVisible(false);
		if (previousFrame!=null) {
			try { previousFrame.setSelected(true); } catch (Exception e) { }
		}

	}

	public void paintNow() {
		update(getGraphics());
	}


    private class JobInfoModel extends AbstractTableModel {

		private final int NUM_COLUMNS = 4;
		public final String colDescription = "Item";
		public final String colNodeName = "Computer";
		public final String colJobStatus = "Status";
		public final String colJobRate = "% done";

		// This hash table stores information about jobs: key=jobID, value=array of column contents
		private Hashtable<Integer, Object[]> tableData;

		// This vector stores the jobID for each table row
		private Vector<Integer> jobIDs;

		/**
		 * Constructor
		 * Initializes data structure used to store job data
		 */
		public JobInfoModel() {
			jobIDs = new Vector<Integer>();
			tableData = new Hashtable<Integer, Object[]>();
		}

		/**
		 * Returns column header
		 */
		public String getColumnName(int column) {
			switch (column) {
			  case 0:
				return colDescription;
			  case 1:
				return colNodeName;
			  case 2:
				return colJobStatus;
			  case 3:
				return colJobRate;
			}
			return "";
		}

		//XXX Should this really be synchronized?
		public synchronized int getColumnCount() {
			return NUM_COLUMNS;
		}

		/**
		 * Returns number of rows in table (num of jobs)
		 */
		public synchronized int getRowCount() {
			int numOfRows = tableData.size();
			return numOfRows;
		}

		/**
		 * Return one table value
		 */
		public synchronized Object getValueAt(int row, int column) {
			// Get jobID for this row
			Integer jobID = jobIDs.get(row);

			// Get columns for this row
			Object[] cols = (Object[])tableData.get(jobID);

			// Return right column
			if (column<0) return "";
			if (column>3) return "";
			return cols[column];

		}

		/**
		 * Adds a new job to table
		 * @param	jobID	jobID of this job
		 * @param	jobDescription	Human-readable description of this job
		 * @param	nodeName	Name (hostname or IP address) of the node processing this job
		 * @param	jobStatus	Current status of this job
		 * @param	jobCompletionRate	Current completion rate of this job (between 0 and 1)
		 */
		public synchronized void addJob(Integer jobID, String jobDescription, String nodeName, String jobStatus, Double jobCompletionRate) {
			// Get next empty row
			int nextEmptyRow = jobIDs.size();

			// Add jobID to vector of jobIDs
			jobIDs.add(jobID);

			// Add columns' contents to hashtable of table data
			Object[] cols = new Object[5];
			cols[0] = jobDescription;
			cols[1] = nodeName;
			cols[2] = jobStatus;
			cols[3] = new String(java.lang.Math.round(jobCompletionRate.doubleValue()*100) + "%");
			cols[4] = jobCompletionRate;		// Kludge: This is invisible column stores completion rate as Double for calculating the average
			tableData.put(jobID, cols);

			// Notify listeners about added row
			fireTableRowsInserted(nextEmptyRow, nextEmptyRow);
		}

		/**
		 * Updates information about an existing job in the table
		 * @param	jobID	jobID of this job
		 * @param	jobStatus	Current status of this job
		 * @param	jobCompletionRate	Current completion rate of this job (between 0 and 1)
		 */
		public synchronized void updateJobStatus(Integer jobID, String jobStatus, Double jobCompletionRate) {
			// Find correct row
			int correctRow = jobIDs.indexOf(jobID);
			if (correctRow == -1)  return;

			// Get old column contents for this row
			Object[] cols = tableData.get(jobID);
			cols[2] = jobStatus;
			cols[3] = new String(java.lang.Math.round(jobCompletionRate.doubleValue()*100) + "%");
			cols[4] = jobCompletionRate;		// Kludge: This is invisible column stores completion rate as Double for calculating the average
			tableData.put(jobID, cols);

			// Notify listeners about updated row
			fireTableRowsUpdated(correctRow, correctRow);
		}

		public synchronized void updateJobNode(Integer jobID, String nodeName) {
			// Find correct row
			int correctRow = jobIDs.indexOf(jobID);
			if (correctRow == -1)  return;

			// Get old column contents for this row
			Object[] cols = tableData.get(jobID);
			cols[1] = nodeName;
			tableData.put(jobID, cols);

			// Notify listeners about updated row
			fireTableRowsUpdated(correctRow, correctRow);
		}


		/**
		 * Clear the table
		 */
		public synchronized void clear() {
			// Find last row
			int lastRow = jobIDs.size();

			// If there is something to clear
			if (lastRow>0) {
				jobIDs.clear();
				tableData.clear();

				// Notify listeners
				fireTableRowsDeleted(0, lastRow-1);
			}
		}

		public double getAverageCompletionRate() {
			Enumeration rowEnum = tableData.elements();
			double rateSum = 0;
			while (rowEnum.hasMoreElements()) {
				Object[] cols = (Object[])rowEnum.nextElement();
				rateSum += ((Double)(cols[4])).doubleValue();
			}
			return rateSum/(double)tableData.size();
		}

	}

}
